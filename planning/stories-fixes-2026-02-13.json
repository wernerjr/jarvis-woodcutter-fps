{
  "$schema": "https://json-schema.org/draft/2020-12/schema",
  "project": "jarvis-woodcutter-fps",
  "updatedAt": "2026-02-13T17:28:00Z",
  "statusLegend": {
    "epic": ["todo", "doing", "done"],
    "story": ["todo", "doing", "done"]
  },
  "epics": [
    {
      "id": "P4",
      "title": "Fixes de UX + persistência (highlight, autosave em menus, forja persistente)",
      "status": "doing",
      "stories": [
        {
          "id": "P4-S1",
          "title": "Highlight de alvo: limpar ao perder alvo + verde mais leve/translúcido",
          "status": "done",
          "objective": "Corrigir bug visual onde o realce verde permanece após perder o alvo e ajustar o highlight para ficar mais sutil.",
          "description": "Hoje, ao mirar/‘passar o mouse’ sobre forja/mesa/fogueira, o highlight fica verde. Ao tirar o alvo (mover a mira), o highlight às vezes não volta ao normal. Precisamos garantir que: (1) o highlight sempre é limpo ao perder alvo, (2) o verde é mais leve e menos chamativo, e (3) tenha aparência um pouco translúcida, sem pós-process pesado.",
          "acceptanceCriteria": [
            "Quando não há alvo válido sob a mira, nenhum objeto permanece com emissive/highlight alterado.",
            "Alternar rapidamente entre alvos não ‘acumula’ highlight nem deixa meshes presos verdes.",
            "O highlight fica mais sutil (menor emissiveIntensity) e com aparência levemente translúcida (sem aumentar custo com transparência em massa).",
            "Não introduz vazamento de memória (listas de meshes antigas limpas).",
            "Docs atualizada: `apps/client/docs/interaction.md` descreve o comportamento final." 
          ],
          "technicalDecisions": [
            "Manter highlight barato: emissive + intensity clamp (sem EffectComposer).",
            "Não alterar materiais para transparent globalmente (risco de overdraw); preferir apenas emissive e, se necessário, ajustar `color` levemente.",
            "Garantir ‘cleanup’ também quando state muda (menu/paused/inventory/forge), não só no loop playing." 
          ]
        },
        {
          "id": "P4-S2",
          "title": "Persistência: enviar state também com menu/pausa abertos",
          "status": "done",
          "objective": "Evitar perda de progresso quando o player abre menu/pausa e fica tempo sem salvar.",
          "description": "Atualmente o autosave (PUT /api/player/state) roda apenas quando `state==='playing'`. Se o player estiver em menu/pausa/inventário/forja e der F5 ou cair energia, pode perder progresso recente. Ajustar o autosave para enviar o estado periodicamente mesmo fora de playing, com guardrails para não spammar e para não salvar estado intermediário inválido.",
          "acceptanceCriteria": [
            "Autosave roda periodicamente mesmo em `paused`, `inventory`, `crafting`, `forge`, `forgeTable` e `menu` (quando houver contexto de persistência).",
            "Não salva com alta frequência (manter intervalo atual ou ligeiramente maior).",
            "Não quebra performance nem spamma toasts.",
            "Se backend estiver offline, falha é silenciosa (comportamento atual).",
            "Docs atualizada (client): mencionar política de autosave em `apps/client/docs/architecture.md` ou doc apropriado." 
          ],
          "technicalDecisions": [
            "Manter `saveNow()` como best-effort e idempotente.",
            "Evitar salvar durante transições críticas se existirem (ex.: no meio de reset/restart) com um flag simples." 
          ]
        },
        {
          "id": "P4-S3",
          "title": "Forja server-side: estado persistente + progresso offline (sem player online)",
          "status": "todo",
          "objective": "Garantir que o estado da forja seja persistido no backend e que a fundição continue ‘offline’ (server-authoritative), consumindo combustível e parando quando input/combustível acabar.",
          "description": "Hoje, ao dar F5 com itens dentro da forja UI, os itens são perdidos porque o estado da forja é client-only. Além disso, você quer que a forja continue processando mesmo sem o player online.\n\nSolução MVP recomendada: persistir o estado da forja no server (DB) por `worldId+forgeId` e aplicar um ‘catch-up’ por tempo decorrido (`now - updatedAt`) quando a forja for consultada/aberta. Esse catch-up consome combustível, consome input, produz output (se houver espaço) e para automaticamente se combustível ou input acabar.",
          "acceptanceCriteria": [
            "Colocar combustível + minério na forja, sair (offline) por alguns minutos, voltar e ver progresso/saída avançados de acordo com o tempo decorrido.",
            "Combustível é gasto corretamente; processamento para quando `burn` chega a 0.",
            "Processamento para quando não houver input (minério) ou quando output estiver cheio.",
            "Não há duplicação de itens (server-authoritative do inventário interno da forja).",
            "Múltiplas forjas no mesmo `worldId` são isoladas por `forgeId`.",
            "Docs atualizada: `apps/client/docs/systems-forge.md` e doc do multiplayer/world state (se aplicável) descrevem o que é server-side e o modelo de catch-up." 
          ],
          "technicalDecisions": [
            "Persistir estado no DB com chave (worldId, forgeId): `enabled`, `burnSec`, `progSec`, `fuelSlots`, `inputSlots`, `outputSlots`, `updatedAt`.",
            "Catch-up é ‘sob demanda’ (quando abrir/consultar): aplicar dt acumulado e salvar novo `updatedAt`.",
            "Consumir combustível e input em passos discretos (ex.: secondsPerIngot) respeitando espaço no output.",
            "Se `enabled=false`, não processar; ainda atualizar `updatedAt` ao salvar alterações de inventário.",
            "Sem cron/job por enquanto (MVP)." 
          ]
        }
      ]
    }
  ]
}
